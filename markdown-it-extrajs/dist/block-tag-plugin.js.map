{
  "version": 3,
  "sources": ["../src/block-tag-plugin.ts"],
  "sourcesContent": ["import type MarkdownIt from \"markdown-it\";\nimport type StateBlock from \"markdown-it/lib/rules_block/state_block.mjs\";\n\nconst blockTagPlugin = (\n  md: MarkdownIt,\n  name: string,\n  options: {\n    tag: string;\n    marker: string;\n    markerCount: number;\n    endMarker?: string;\n  },\n): void => {\n  const markerStr = options.marker.charAt(0);\n  const markerCount = options.markerCount;\n  const endMarkerStr = options.endMarker ? options.endMarker.charAt(0) : markerStr;\n\n  const blockTagRule = (\n    state: StateBlock,\n    startLine: number,\n    endLine: number,\n    silent: boolean,\n  ) => {\n    let start = state.bMarks[startLine] + state.tShift[startLine];\n    let max = state.eMarks[startLine];\n\n    if (markerStr !== state.src[start]) return false;\n\n    let pos: number;\n    for (pos = start + 1; pos <= max; pos++) {\n      if (markerStr !== state.src[pos]) {\n        break;\n      }\n    }\n\n    const count = pos - start;\n    if (count < markerCount) return false;\n\n    const params = state.src.slice(pos, max).trim();\n\n    const nameAttr = params.split(\" \")[0];\n    if (!nameAttr || name !== nameAttr) return false;\n    const markup = `${state.src.slice(start, pos)} ${nameAttr}`;\n\n    if (silent) return true;\n\n    const stack: { type: \"open\" | \"close\"; line: number }[] = [{\n      type: \"open\",\n      line: startLine,\n    }];\n    let autoClosed = false;\n\n    let nextLine: number;\n    let markupEnd = \"<!-- auto-closed -->\";\n    for (nextLine = startLine + 1; nextLine <= endLine; nextLine++) {\n      start = state.bMarks[nextLine] + state.tShift[nextLine];\n      max = state.eMarks[nextLine];\n\n      if (markerStr === state.src[start]) {\n        for (pos = start + 1; pos <= max; pos++) {\n          if (markerStr !== state.src[pos]) break;\n        }\n\n        const openCount = pos - start;\n        if (openCount >= markerCount) {\n          const newParams = state.src.slice(pos, max).trim();\n          const newNameAttr = newParams.split(\" \")[0];\n          if (newNameAttr) {\n            stack.push({ type: \"open\", line: nextLine });\n          } else if (markerStr === endMarkerStr) {\n            pos = state.skipSpaces(pos);\n            if (pos < max) continue;\n\n            stack.push({ type: \"close\", line: nextLine });\n            if (\n              stack.filter((s) => s.type === \"open\").length ===\n              stack.filter((s) => s.type === \"close\").length\n            ) {\n              markupEnd = state.src.slice(start, pos);\n              autoClosed = true;\n              break;\n            }\n          }\n          continue;\n        }\n      }\n\n      if (endMarkerStr === state.src[start]) {\n        for (pos = start + 1; pos <= max; pos++) {\n          if (endMarkerStr !== state.src[pos]) break;\n        }\n\n        const closeCount = pos - start;\n        if (closeCount >= markerCount) {\n          pos = state.skipSpaces(pos);\n          if (pos < max) continue;\n\n          stack.push({ type: \"close\", line: nextLine });\n          if (\n            stack.filter((s) => s.type === \"open\").length ===\n            stack.filter((s) => s.type === \"close\").length\n          ) {\n            markupEnd = state.src.slice(start, pos);\n            autoClosed = true;\n            break;\n          }\n        }\n      }\n    }\n\n    const lineMaxOrg = state.lineMax;\n    state.lineMax = nextLine;\n\n    const tokenOpen = state.push(`block_tag_${name}_open`, options.tag, 1);\n    tokenOpen.markup = markup;\n    tokenOpen.block = true;\n    tokenOpen.info = params;\n    tokenOpen.map = [startLine, nextLine - (autoClosed ? 0 : 1)];\n    tokenOpen.attrJoin(\"data-block-tag-name\", nameAttr);\n\n    if (options.tag === \"pre\") {\n      const content = state.getLines(\n        startLine + 1,\n        nextLine,\n        state.blkIndent,\n        true,\n      );\n      const token = state.push(\"text\", \"\", 0);\n      token.content = content;\n    } else {\n      state.md.block.tokenize(state, startLine + 1, nextLine);\n    }\n\n    const tokenClose = state.push(`block_tag_${name}_close`, options.tag, -1);\n    tokenClose.markup = markupEnd;\n    tokenClose.block = true;\n    tokenClose.map = [startLine, nextLine - (autoClosed ? 0 : 1)];\n\n    state.lineMax = lineMaxOrg;\n    state.line = nextLine + (autoClosed ? 1 : 0);\n\n    return true;\n  };\n\n  md.block.ruler.before(\"fence\", `block_tag_${name}`, blockTagRule, {\n    alt: [\"paragraph\", \"reference\", \"blockquote\", \"list\"],\n  });\n};\n\nexport default blockTagPlugin;\n"],
  "mappings": "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",
  "names": []
}
