{
  "version": 3,
  "sources": ["../src/block-tag-plugin.ts"],
  "sourcesContent": ["import type MarkdownIt from \"markdown-it\";\nimport type StateBlock from \"markdown-it/lib/rules_block/state_block.mjs\";\n\nconst blockTagPlugin = (\n  md: MarkdownIt,\n  name: string,\n  options: {\n    tag: string;\n    marker: string;\n    markerCount: number;\n    endMarker?: string;\n  },\n): void => {\n  const markerStr = options.marker;\n  const markerChar = markerStr.charCodeAt(0);\n  const markerCount = options.markerCount;\n  const endMarkerStr = options.endMarker || markerStr;\n  const endMarkerChar = endMarkerStr.charCodeAt(0);\n\n  const blockTagRule = (\n    state: StateBlock,\n    startLine: number,\n    endLine: number,\n    silent: boolean,\n  ) => {\n    let start = state.bMarks[startLine];\n    let max = state.eMarks[startLine];\n\n    if (markerChar !== state.src.charCodeAt(start)) return false;\n\n    let pos: number;\n    for (pos = start + 1; pos <= max; pos++) {\n      if (markerStr !== state.src[pos]) {\n        break;\n      }\n    }\n\n    const count = pos - start;\n    if (count < markerCount) return false;\n\n    const markup = state.src.slice(start, pos);\n    const params = state.src.slice(pos, max).trim();\n\n    const nameAttr = params.split(\" \")[0];\n    if (!nameAttr) return false;\n\n    if (silent) return true;\n\n    const stack: { type: \"open\" | \"close\"; line: number }[] = [{\n      type: \"open\",\n      line: startLine,\n    }];\n    let autoClosed = false;\n\n    let nextLine = startLine;\n    for (nextLine = startLine + 1; nextLine < endLine; nextLine++) {\n      start = state.bMarks[nextLine];\n      max = state.eMarks[nextLine];\n\n      if (markerChar === state.src.charCodeAt(start)) {\n        for (pos = start + 1; pos <= max; pos++) {\n          if (markerStr !== state.src[pos]) break;\n        }\n\n        const openCount = pos - start;\n        if (openCount >= markerCount) {\n          const newParams = state.src.slice(pos, max).trim();\n          const newNameAttr = newParams.split(\" \")[0];\n          if (newNameAttr) {\n            stack.push({ type: \"open\", line: nextLine });\n          } else if (markerChar === endMarkerChar) {\n            pos = state.skipSpaces(pos);\n            if (pos < max) continue;\n\n            stack.push({ type: \"close\", line: nextLine });\n            if (\n              stack.filter((s) => s.type === \"open\").length ===\n              stack.filter((s) => s.type === \"close\").length\n            ) {\n              autoClosed = true;\n              break;\n            }\n          }\n          continue;\n        }\n      }\n\n      if (endMarkerChar === state.src.charCodeAt(start)) {\n        for (pos = start + 1; pos <= max; pos++) {\n          if (endMarkerStr !== state.src[pos]) break;\n        }\n\n        const closeCount = pos - start;\n        if (closeCount >= markerCount) {\n          pos = state.skipSpaces(pos);\n          if (pos < max) continue;\n\n          stack.push({ type: \"close\", line: nextLine });\n          if (\n            stack.filter((s) => s.type === \"open\").length ===\n            stack.filter((s) => s.type === \"close\").length\n          ) {\n            autoClosed = true;\n            break;\n          }\n        }\n      }\n    }\n\n    const tokenOpen = state.push(`block_tag_${name}_open`, options.tag, 1);\n    tokenOpen.markup = markup;\n    tokenOpen.block = true;\n    tokenOpen.info = params;\n    tokenOpen.map = [startLine, nextLine];\n    tokenOpen.attrJoin(\"name\", nameAttr);\n\n    if (options.tag === \"pre\") {\n      const content = state.getLines(\n        startLine + 1,\n        nextLine,\n        state.blkIndent,\n        true,\n      );\n      const token = state.push(\"text\", \"\", 0);\n      token.content = content;\n    } else {\n      state.md.block.tokenize(state, startLine + 1, nextLine);\n    }\n\n    if (autoClosed) {\n      const tokenClose = state.push(`block_tag_${name}_close`, options.tag, -1);\n      tokenClose.markup = state.src.slice(start, pos);\n      tokenClose.block = true;\n      tokenClose.map = [startLine, nextLine];\n    }\n\n    state.line = nextLine + (autoClosed ? 1 : 0);\n\n    return true;\n  };\n\n  md.block.ruler.before(\"fence\", `block_tag_${name}`, blockTagRule, {\n    alt: [\"paragraph\", \"reference\", \"blockquote\", \"list\"],\n  });\n};\n\nexport default blockTagPlugin;\n"],
  "mappings": "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",
  "names": []
}
