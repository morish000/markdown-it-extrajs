{
  "version": 3,
  "sources": ["../src/inline-tag-plugin.ts"],
  "sourcesContent": ["import type MarkdownIt from \"markdown-it\";\nimport type StateInline from \"markdown-it/lib/rules_inline/state_inline.mjs\";\nimport type { Delimiter } from \"markdown-it/lib/rules_inline/state_inline.mjs\";\n\nconst inlineTagPlugin = (\n  md: MarkdownIt,\n  name: string,\n  options: {\n    tag: string;\n    marker: string;\n    markerCount: number;\n    endMarker?: string;\n  },\n): void => {\n  const markerStr = options.marker;\n  const markerChar = markerStr.charCodeAt(0);\n  const markerCount = options.markerCount;\n  const endMarkerStr = options.endMarker || markerStr;\n  const endMarkerChar = endMarkerStr.charCodeAt(0);\n\n  const tokenize = (state: StateInline, silent: boolean) => {\n    const start = state.pos;\n    const marker = state.src.charCodeAt(start);\n\n    if (silent) return false;\n\n    if (marker !== markerChar && marker !== endMarkerChar) return false;\n\n    const scanned = state.scanDelims(state.pos, true);\n    let len = scanned.length;\n    const ch = String.fromCharCode(marker);\n\n    if (len < markerCount) return false;\n\n    const loneMarkerCount = len % markerCount;\n    if (loneMarkerCount) {\n      const token = state.push(\"text\", \"\", 0);\n      token.content = ch.repeat(loneMarkerCount);\n      len -= loneMarkerCount;\n    }\n\n    const canOpen = (marker === markerChar) && scanned.can_open;\n    const canClose = (marker === endMarkerChar) && scanned.can_close;\n\n    const tokenContent = ch.repeat(markerCount);\n    for (let i = 0; i < len; i += markerCount) {\n      const token = state.push(\"text\", \"\", 0);\n      token.content = tokenContent;\n      if (!canOpen && !canClose) continue;\n      state.delimiters.push({\n        marker,\n        length: markerCount,\n        token: state.tokens.length - 1,\n        end: -1,\n        open: canOpen,\n        close: canClose,\n      });\n    }\n\n    state.pos += scanned.length;\n\n    return true;\n  };\n\n  const postProcess = (state: StateInline) => {\n    const delimiters = state.delimiters;\n    const loneMarkers: number[] = [];\n    const stack: typeof delimiters = [];\n\n    if (markerStr !== endMarkerStr) {\n      for (let i = 0; i < delimiters.length; i++) {\n        const delim = delimiters[i];\n        if (delim.marker === markerChar) {\n          stack.push(delim);\n        } else if (delim.marker === endMarkerChar) {\n          if (stack.length > 0) {\n            const startDelim = stack.pop() as Delimiter;\n            startDelim.open = true;\n            startDelim.end = i;\n            delim.end = -1;\n            delim.close = true;\n          }\n        }\n      }\n    }\n\n    const loneMarkerRegExp = new RegExp(`^(${endMarkerStr})+$`);\n    for (let i = 0; i < delimiters.length; i++) {\n      const startDelim = delimiters[i];\n      if (startDelim.marker !== markerChar) {\n        continue;\n      }\n      if (startDelim.end === -1) {\n        continue;\n      }\n\n      const endDelim = delimiters[startDelim.end];\n\n      const tokenOpen = state.tokens[startDelim.token];\n      tokenOpen.type = `inline_tag_${name}_open`;\n      tokenOpen.tag = options.tag;\n      tokenOpen.nesting = 1;\n      tokenOpen.content = \"\";\n\n      const tokenClose = state.tokens[endDelim.token];\n      tokenClose.type = `inline_tag_${name}_close`;\n      tokenClose.tag = options.tag;\n      tokenClose.nesting = -1;\n      tokenClose.content = \"\";\n\n      if (\n        state.tokens[endDelim.token - 1].type === \"text\" &&\n        loneMarkerRegExp.test(state.tokens[endDelim.token - 1].content)\n      ) {\n        loneMarkers.push(endDelim.token - 1);\n      }\n    }\n\n    while (loneMarkers.length) {\n      const i = loneMarkers.pop();\n      if (i === undefined) continue;\n\n      let j = i + 1;\n\n      while (\n        j < state.tokens.length &&\n        state.tokens[j].type === `inline_tag_${name}_close`\n      ) {\n        j++;\n      }\n\n      j--;\n\n      if (i !== j) {\n        const token = state.tokens[j];\n        state.tokens[j] = state.tokens[i];\n        state.tokens[i] = token;\n      }\n    }\n    return true;\n  };\n\n  md.inline.ruler.before(\"emphasis\", `inline_tag_${name}`, tokenize);\n  md.inline.ruler2.before(\"emphasis\", `inline_tag_${name}`, postProcess);\n};\n\nexport default inlineTagPlugin;\n"],
  "mappings": "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",
  "names": []
}
